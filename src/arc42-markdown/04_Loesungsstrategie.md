title=4. Lösungsstrategie
type=page
status=published
~~~~~~

Die folgende Tabelle stellt die Qualitätsziele von DokChess (siehe Abschnitt 1.2) passenden Architekturansätzen gegenüber, und erleichtert so einen Einstieg in die Lösung.

| Qualitätsziel | Dem zuträgliche Ansätze in der Architektur |
|---------------|--------------------------------------------|
Zugängliches Beispiel (Analysierbarkeit) | <ul><li>Architekturüberblick gegliedert nach arc42<li>Explizites, objektorientiertes Domänenmodell<li>Modul-, Klassen- und Methodennamen in Deutsch, um englische Schachbegriffe zu vermeiden<li>Ausführliche Dokumentation der öffentlichen Schnittstellen in javadoc</ul> || Einladende Experimentierplattform (Änderbarkeit)|<ul><li>verbreitete Programmiersprache Java, →(a)<li>Schnittstellen für Kernabstraktionen (z.B. Stellungsbewertung, Spielregeln)<li>Unveränderliche Objekte (Stellung, Zug, ...) erleichtern Implementierung vieler Algorithmen<li>„Zusammenstecken“ der Bestandteile mit Dependency Injection führt zu Austauschbarkeit, →(b)<li>Hohe Testabdeckung als Sicherheitsnetz</ul>||Bestehende Frontends nutzen (Interoperabilität)|<ul><li>Verwendung des verbreiteten Kommunikationsprotokolls xboard, →(c), <li>Einsatz des portablen Java, →(a)</ul>||Attraktive Spielstärke (Attraktivität)|<ul><li>Integration von Eröffnungsbibliotheken →(d)<li>Implementierung des Minimax-Algorithmus und einer geeigneter Stellungsbewertung, →(e)<li>Integrationstests mit Schachaufgaben für taktische Motive und Mattsituationen</ul>|| Schnelles Antworten auf Züge (Effizienz) |<ul><li>Reactive Extensions für nebenläufige Berechnung mit neu gefundenen besseren Zügen als Events →(f)<li>Optimierung des Minimax durch Alpha-Beta-Suche, →(e)<li>Effiziente Implementierung des Domänenmodells<li>Integrationstests mit Zeitvorgaben</ul>|Kleine Buchstaben in Klammern →(x) verorten einzelne Ansätze aus der Tabelle im folgenden schematischen Bild. Der restliche Abschnitt 4 führt in wesentliche Architekturaspekte ein und verweist auf weitere Informationen dazu in diesem Kapitel.

![Informelles Überblicksbild für DokChess](images/Abb09_06_Ueberblick.png "Informelles Überblicksbild für DokChess")

## 4.1	Aufbau von DokChess
DokChess ist als Java-Programm mit main-Routine realisiert. Es zerfällt grob in folgende Teile:
* eine Implementierung der Schachregeln* die eigentliche Engine, welche die Züge ermittelt* die Anbindung an eine grafische Benutzeroberfläche über das XBoard-Protokoll* einen Adapter für ein konkretes Eröffnungsbibliotheksformat (Polyglot Opening Book)
Diese Zerlegung ermöglicht es, Dinge wie das Kommunikationsprotokoll oder das Eröffnungsbibliotheksformat bei Bedarf auszutauschen. Alle Teile sind durch Schnittstellen abstrahiert, die Implementierungen werden per Dependency Injection zusammengesteckt (→ Bausteinsicht 9.5, → Konzept 8.1 „Abhängigkeiten zwischen Modulen. Die Zerlegung erlaubt es weiterhin die Software, allen voran die Schachalgorithmen, leicht automatisiert zu testen (→ Konzept 8.7 „Testbarkeit“). Die Interaktion zwischen Algorithmen­Teilen erfolgt über den Austausch fachlich motivierter Datenstrukturen, realisiert als Klassen (Figur, Zug, ... → Konzept 8.2 „Schach­Domänenmodell“). Hier wurde bewusst eine bessere Verständlichkeit angestrebt, auf Kosten von Effizienz. Gleichwohl erreicht DokChess eine akzeptable Spielstärke, wie ein Durchspielen der entsprechenden Szenarien zeigt (→ 10. Qualitätsszenarien).Zentrales Element beim Entwurf der Datenstrukturen ist die Spielsituation: Welche Figuren gerade wo stehen und was sonst noch zur Stellung dazu gehört (z. B. wer am Zug ist). Auch hier ging bei der Implementierung der fachlich motivierten Klasse dazu Lesbarkeit vor Effizienz. Ein wichtiger Aspekt dabei: Wie alle anderen fachlichen Klassen ist auch sie unveränderlich (→ Entscheidung 9.2 „Sind Stellungsobjekte veränderlich oder nicht?“).## 9.4 Spielstrategie
Für die Integration von Eröffnungsbibliotheken wurde das Dateiformat „Polyglot Opening Book“ implementiert (→ Bausteinsicht 5.5 “Eröffnung“), DokChess antwortet dadurch zu Beginn mit „Buchwissen“. Für die Spielstrategie im weiteren Partieverlauf ist ein klassischer Minimax­-Algorithmus mit fester Suchtiefe im Spielbaum verantwortlich. Dessen Basis-Implementierung ist nicht nebenläufig, die Bewertung einer Stellung an einem Terminalknoten im Spielbaum basiert ausschließlich auf dem Material (→ Bausteinsicht Ebene 2, 9.5.6 “Engine“). Diese einfachen Implementierungen erfüllen unter den gegebenen Randbedingungen bereits die Qualitätsszenarien.Eine Alpha­Beta­-Suche illustriert den einfachen Austausch von Algorithmen. Spielstärke und/oder Effizienz verbessern sich durch die bei gleicher Rechenzeit tiefere Suche im Baum erheblich. Die unveränderlichen Datenstrukturen in DokChess erleichtern auch das Implementieren nebenläufiger Algorithmen; ein paralleler Minimax ist ebenfalls als Beispiel enthalten.## 4.3 Die AnbindungDokChess besitzt keine grafische Benutzeroberfläche; die Kommunikation erfolgt stattdessen über die Standardein­- und -­ausgabe. Als Kommunikationsprotokoll kommt das textbasierte XBoard-­Protokoll zum Einsatz (→ Entscheidung 9.1 „Wie kommuniziert die Engine mit der Außenwelt?“). DokChess lässt sich interaktiv per Kommandozeile bedienen, wenn man die XBoard­-Kommandos kennt und die Engine-Antworten zu deuten weiß (→ Konzept 8.3 „Benutzungsoberfläche“), siehe folgendes Bild.![DokChess über die Kommandozeile bedienen](images/Abb09_07_DokChess_Kommandozeile.png "DokChess über die Kommandozeile bedienen")
Die eigentliche Engine von DokChess wird dabei über einen reaktiven Ansatz („Reactive Extensions“) angebunden (→ 6. Laufzeitsicht, „Zugermittlung Walkthrough“). DokChess bleibt so auch während der Zugermittlung ansprechbar, ein Benutzer kann zum Beispiel ein sofortiges Ziehen erzwingen. Die Integration von DokChess in ein UI erfolgt unter Windows über eine Batch­-Datei (*.bat), welche die Java Virtual Machine (JVM) unter Angabe der Klasse mit main­-Methode startet (→ 7. Verteilungssicht).
